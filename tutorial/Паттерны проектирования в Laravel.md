#develop/tree 

Паттернов проектирования очень много и далеко не все из них стоит изучать сразу. Но есть несколько паттернов, о которых надо поговорить здесь и сейчас, поскольку на их использовании строится сам фреймворк Laravel, а значит нам требуется их понимание. По этой же причине мы будем приводить примеры, напрямую связанные с типовой работой с Laravel.

Разумеется, главный паттерн, который использует Laravel (как и почти любой другой современный php-фреймворк) — это MVC. Но данный шаблон вам уже слишком хорошо знаком по прошлому курсу, чтобы снова о нём говорить :)

# Фасад

Этот шаблон проектирования следует рассмотреть особенно внимательно, потому что он используется в Laravel абсолютно повсеместно. Начнём с определения паттерна в целом.

**Фасад** — это структурный паттерн, который предоставляет простой (но урезанный) интерфейс к сложной системе объектов, библиотеке или фреймворку.

Шаблон фасад обеспечивает комбинированный интерфейс для набора интерфейсов в подсистеме. Фасад определяет высокоуровневый интерфейс, упрощающий использование подсистемы. Однако шаблон фасада нужен не только для того, чтобы скрыть плохой код. Его можно использовать также и для создания простого, общедоступного интерфейса, который каким-то образом связывает несколько классов, работающих вместе. Важное отличие фасада от других схожих паттернов вроде прокси или адаптера в том, что фасад может скрывать внутри себя работу сразу с несколькими классами, предоставляя наружу один простой интерфейс. Звучит сложно, но давайте разбираться как это работает и зачем Laravel так активно использует этот паттерн.

Предположим, вы имеете дело с большой подсистемой с сотнями общедоступных методов, но вам нужны лишь некоторые из них. Вы хотите, чтобы фасад правильно создавал различные классы в подсистеме и предоставлял вам эти интерфейсы, чтобы их можно было легко использовать. Все фасады Laravel определены в пространстве имен Illuminate\Support\Facades.

Пример использования фасада
Давайте разберёмся с тем, как функционируют фасады в Laravel на примере работы с одним из компонентов.
Предположим, мы собираемся воспользоваться компонентом Cache, который позволяет работать с кэшом — сохранять и получать данные из хранилища кэша по ключу.

```php
use Illuminate\Support\Facades\Cache;

...

public function index()
{
    $key = 'cachekey';
    $value = Cache::get($key);
}
```

Что происходит далее? Надо понимать, что сам класс Cache является классом-пустышкой и не содержит совершенно никакой логики и в нём также нет никаких методов, вроде вызываемого get(). Но как тогда всё работает и не происходит никаких ошибок при вызове этого кода?

Дело в том, что благодаря поддержки в PHP «магических методов», любые вызовы несуществующих методов перехватываются родительским классом любого фасада — тем самым Illuminate\Support\Facades.
Далее, используя внутреннее имя вызываемого фасада (кстати, все доступные фасады и их имена перечислены в документации). Затем это внутреннее имя используется для разрешения в реальный объект через DI-контейнер.
На примере кэша последовательность выходит такая:

Сервис-провайдер компонента кэширования указан как доступный в конфиге app.php

Сервис-провайдер регистрирует биндинг на компонент кэширования под именем app:

```php
public function register()
{
    $this->app->singleton('cache', function ($app) {
    	return new CacheManager($app);
	});
}
```

При вызове метода Cache::get() фасад по имени cache получает объект класса CacheManager, который был зарегистрирован в DIC и вызывает его метод get()

# Билдер

Шаблон Builder является одним из основных шаблонов проектирования Laravel. Он отделяет построение сложного объекта от его представления, так что один и тот же процесс построения может создавать разные представления.

Все порождающие паттерны (к которым и относится Builder) сосредоточены на пошаговом создании подготовленного объекта. Builder даёт возможность использовать один и тот же код строительства для получения разных представлений объектов. Главный пример использования этого паттерна внутри фреймворка — это построитель запроса от компонента Eloquent.
О компоненте QueryBuilder мы еще поговорим отдельно, а пока посмотрим на пример реализации этого паттерна в отрыве от фреймворка, чтобы лучше понять его суть.

Поскольку название этого паттерна переводится как «строитель», то и давайте построим с его помощью что-нибудь. Например, автомобиль:

```php
<?php 
 
class Car {
    
    private $brand;
    private $machineType;
    private $mileage;

    public function __construct($brand, $machineType, $mileage) {
        $this->brand = $brand;
        $this->machineType = $machineType;
        $this->mileage = $mileage;
    }

    public function getMileAge() {
        return $this->mileage;
    }

    public function getMachineType() {
        return $this->machineType;
    }

    public function getBrand() {
        return $this->brand;
    }

    public function setBrand($brand){
        if (is_null($brand)) {
            return "Вы должны указать марку машины";
        }
    
        $this->brand = $brand;
        return "Марка машины сохранена";
    }

    public function addMileage($mileage){
        $this->mileage += $mileage;
    }
}
```

```php
<?php 

class CarBuilder {

    private $brand = null;
    private $machineType = null;
    private $mileage = 0 ;
 
    public function setBrand($brand) {
        $this->brand = $brand;
        return $this;
    }

    public function setMachineType($type) {
        $this->machineType = $type;
        return $this;
    }

    public function setmileAge($mile) {
        $this->mileage = $mile;
        return $this;
    }

    public function build(): Car {
        $car = new Car
    (
        $this->brand, 
        $this->machineType, 
        $this->mileage
    );
        return $car;
    }
}
```

Теперь соберём всё вместе:

```php
<?php

$cars = [];

$avansa = (new CarBuilder())
    ->setBrand('Toyota')
    ->setMachineType('Petrol')
    ->setMileage(8000)
    ->build();

array_push($cars, $avansa);

$fuso = (new CarBuilder())
    ->setBrand('Mithsubishi')
    ->setMachineType('Diesel')
    ->setMachineCapacity(2000)
    ->build(); 

array_push($cars, $fuso); 
```

# Репозиторий

Репозиторий (ещё можно называть «хранитель») — это слой абстракции, инкапсулирующий в себе всё, что относится к способу хранения данных. Его предназначение это отделять бизнес-логику от деталей реализации слоя доступа к данным.

Репозиторий работает как посредник и отделяет модели от их способа хранения. Иными словами, обращаясь к репозиторию за данными, вы используете один из множества публичных методов и получаете в ответ коллекцию моделей.

Ещё одним важным преимуществом этого шаблона является то, что он позволяет использовать принцип инверсии зависимостей (об этом принципе пойдет речь далее). Это делает код более устойчивым к изменениям. Например, если позже было принято решение переключиться на источник данных (БД), который не поддерживается Eloquent.

Концептуально, Репозиторий инкапсулирует в себе набор объектов, которые хранятся в БД и операции, доступные над ними, предлагая более объектно-ориентированное представление для слоя хранения данных.

# Отношения между репозиторием и ORM

Возможно у вас возник вопрос: Зачем использовать репозиторий, если я использую ORM?
Ведь ORM уже позволяет работать с данными через объекты-модели и абстрагирует внутри себя детали реализации конкретной СУБД, что позволяет легко сменить, к примеру, MySQL на PostgreSQL.

Однако могут быть ситуации, когда хранение данных представляет собой нечто более сложное и специфичное, чем обычный ORM. Тогда такой слой данных инкапсулируется с помощью паттерна репозиторий.
К примеру, если вы захотите сменить базу данных на что-нибудь отличное от SQL (например, mongodb). Также репозиторий позволит легко добавить поддержку нескольких источников данных, скрывая внутри себя всю логику по работе с ними.

Применение репозитория помогает поддерживать порядок в коде и избегать дублирования, поскольку логика, связанная с базой данных, хранится в одном месте. Хотя это преимущество не сразу проявляется в небольших проектах, оно становится более заметным в крупномасштабных проектах, которые необходимо поддерживать в течение многих лет.

# Репозиторий без БД и моделей

В параграфах выше шла речь исключительно об использовании паттерна репозиторий в контексте работы с БД. Однако, использование репозитория не ограничено только работой с базой данных. Вы можете использовать этот паттерн и для любых других целей, когда требуется запросить данные и получить в ответ коллекцию объектов. В таком случае источником этих данных может быть внешний API.
Репозиторий поможет вам скрыть детали работы с этим поставщиком данных, что впоследствии позволит его легко заменить.

## Примеры кода

```php
class RemoteRepository
{
    public function __construct(private \Psr\Http\Client\ClientInterface $httpClient)
    {
    }

    public function getMovies(string $imdbId): ?array
    {
        $response = $this->httpClient->sendRequest($imdbId);

        return json_decode($response->getBody()->getContents(), true);
    }
}
```

```php
<?php

$client = new \GuzzleHttp\Client();
$repository = new RemoteRepository($client);

$movies = $repository->getMovies('tt39105467134');
```

links: https://www.kobzarev.com/programming/di/

---

prev:[[Dependency Injection (lesson)]] next:[[Dependency injection]]
