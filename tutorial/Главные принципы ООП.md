#develop/tree

С этой главы мы начинаем углубленное рассмотрение принципов объектно-ориентированного подхода. В прошлом курсе мы уже касались этой темы, но тогда у вас еще не хватало необходимого опыта, чтобы на практике понять важность и необходимость правильного применения всех постулатов ООП. Теперь же, когда у вас за плечами пройденный курс, изученный фреймворк, а также много практики, самое время перейти на следующий этап — изучить как проектировать по настоящему сложные проекты.

## Принципы объектно-ориентированного проектирования

О чём же вообще идёт речь и почему недостатоно просто знать как определяются те же классы и объекты, чтобы считать, что ваш код написан в настоящем ООП-подходе?

Для начала следует немного освежить теорию из прошлого курса. Из подразделов «Инкапсуляция и полиморфизм» и «Проектирование» главы «Правильная архитектура» вы узнали, что поддержка ООП в PHP включает в себя возможность наследования классов и применения интерфейсов. Вы также знаете, что при проектировании программы желательно, чтобы классы:

1.  Отвечали только за свои задачи, т. е. должна быть четкая специализация и понимание, что входит в зону ответственности каждого класса
2.  Использовали интерфейсы, чтобы задать так называемый «публичный контракт»
3.  Скрывали детали своей внутренней реализации, используя модификаторы доступа

Однако, приведенные примеры были достаточно просты, т. к. вы еще даже не знали что такое фреймворк. Этот курс является заключительным в профессии, а значит теперь можно поговорить и на более сложные и комплексные темы.

### Зачем нужны принципы ООП

Чем отличается опытный профессионал от новичка?

Представьте себе опытного художника или иллюстратора, перед которым стоит задача нарисовать некий образ, например, человека в движении. Опытный иллюстратор прежде чем сделает свой первый штрих, представит у себя в голове общий план работы. Благодаря накопленному опыту и знанию теории изобразительного искусства, каждая линия на рисунке будет осмысленной и находиться в своем месте. Иными словами, все элементы рисунка будут подчинены заранее задуманной композиции. Сам же процесс работы над «креативом» будет инкрементальным, когда вначале прорисовываются самые общие контуры, а завершается весь процесс мелкими деталями. Такой процесс работы возможен, потому что у художника есть та самая «база»: совокупность знания и опыта.

Новичок же, возможно, сразу примется за детальную прорисовку отдельного объекта, не понимая и не представляя как строится вся картина целиком и из каких кирпичиков она состоит.

Такая же история и с программированием. Опытный разработчик, оценивая техническое задание, представляет как он будет проектировать будущий проект, начиная от самых крупных блоков. Т.е. такой специалист сразу может представить основные этапы разработки и что они в себя включают.

Принципы проектирования содержат в себе рекомендации и даже практически готовые рецепты. Такие рецепты позволяют сразу писать качественный код, который легко поддаётся расширению, а его поддержка по мере развития проекта не оборачивается головной болью и желанием переписать проект с нуля.

Именно о таких принципах и пойдёт речь в следующих главах.

-   AuthController.php

```php
<?php

namespace App\Http\Controllers;

use App\Http\Requests\LoginRequest;
use App\Http\Requests\UserRequest;
use App\Models\User;
use Illuminate\Contracts\Support\Responsable;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Auth;

class AuthController extends Controller
{
    /**
     * @param UserRequest $request
     * @return JsonResponse|Responsable
     */
    public function register(UserRequest $request)
    {
        $params = $request->safe()->except('file');
        $user = User::create($params);
        $token = $user->createToken('auth-token');

        return $this->success([
            'user' => $user,
            'token' => $token->plainTextToken,
        ], 201);
    }

    /**
     * @param LoginRequest $request
     * @return JsonResponse|Responsable
     */
    public function login(LoginRequest $request)
    {
        if (!Auth::attempt($request->validated())) {
            // todo рассказать о возможности ограничения к-ва запросов на один роут от одного пользователя
            abort(401, trans('auth.failed'));
        }

        $token = Auth::user()->createToken('auth-token');

        return $this->success(['token' => $token->plainTextToken]);
    }

    /**
     * @return JsonResponse|Responsable
     */
    public function logout()
    {
        Auth::user()->tokens()->delete();

        return $this->success(null, 204);
    }
}
```

[[Что такое SOLID]]
