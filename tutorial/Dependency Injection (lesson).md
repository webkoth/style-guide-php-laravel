#develop/tree 

# Два главных принципа инверсии зависимостей

Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

# Инверсия зависимостей детально

Принцип декларирует, что модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа модулей должны зависеть от абстракций; сами абстракции не должны зависеть от деталей, а вот детали должны зависеть от абстракций.

Следование принципу инверсии зависимостей «заставляет» реализовывать высокоуровневые компоненты без встраивания зависимостей от конкретных низкоуровневых классов, что, например, сильно упрощает замену используемых зависимостей как по бизнес-требованиям, так и для целей тестирования. При этом зависимость формируется не от конкретной реализации, а от абстракции — реализуемого зависимостью интерфейса.

Например, мы реализуем хранение документов в веб-приложении. На первый взгляд, кажется логичным добавить зависимость от модулей работы с файловой системой непосредственно в класс, отвечающий за высокоуровневую работу с этими документами. Но в перспективе такая зависимость может создать проблемы — например, нам потребуется хранить данные не только на диске, но и в облаке. Если зависимость внедрена от реализации, то мы столкнёмся с необходимостью её переработки. Если же зависимость выведена на уровень абстракции (интерфейса), то нам будет достаточно реализовать функционал работы с облаком, соответствующий ранее созданному интерфейсу работы с файлами.

Принцип инверсии зависимостей часто упрощает следованию принципу подстановки Барбары Лисков. Выделение абстракций и встраивание зависимостей от них снижает вероятность того, что в новом классе мы не полностью реализуем контракт базового класса, который мы расширяем в рамках нового.

Внедрение зависимостей на примерах
Определение: «Внедрение зависимости означает, что один объект предоставляет или внедряет зависимости другого объекта». Это всё.

Предположим, мы разрабатываем платёжный шлюз, который должен уметь работать с платежными системами и подписками. Как может выглядеть взаимодействие классов в этом случае:

```php
<?php

class PaymentGateWay
{
    protected $gateway;

    public function __construct(ChargeBee $chargeBee)
    {
        $this->gateway = $chargeBee;
    }

    public function charge()
    {
        $this->gateway->payNow();
    }
}

class ChargeBee
{
    protected $subscription;

    public function __construct(ChargeBeeSubscription $subscription)
    {
        $this->subscription = $subscription;
    }

    public function removeSubscription()
    {
        $this->subscription->cancelSubscription();
    }

    public function payNow()
    {
        //do stuff
    }
}

class ChargeBeeSubscription
{
    public function createSubscription()
    {
        //do stuff
    }

    public function cancelSubscription()
    {
        //do stuff
    }
}

$subscription = new ChargeBeeSubscription();
$chargeBee = new ChargeBee($subscription);
$gateway = new PaymentGateWay($chargeBee);
```

В приведённом коде, класс **ChargeBee** использует объект класса **ChargeBeeSubscription**, что означает, что если вы хотите создать объект **ChargeBee**, то понадобится объект **ChargeBeeSubscription**. Тоже самое и с **PaymentGateWay** и **ChargeBee**. Чтобы создать объект **PaymentGateWay** прежде вы должны подготовить объект **ChargeBee**.

Мы внедряем объект **ChargeBeeSubscription** в конструктор класса **ChargeBee** и объект **ChargeBee** в конструктор **PaymentGateWay**.

# Контейнер внедрения зависимостей

Одним из ключевых моментов инверсии зависимостей является динамическое обеспечение объекта другими необходимыми ему объектами в системе. Это делается через DIC (контейнер внедрения зависимостей).

Например, в приведенном выше примере объекту A необходимо управлять сеансом. Раньше нам всегда приходилось писать код в A, чтобы получить объект Session. С контейнерным менеджером нам нужно только сообщить контейнеру, что класс A нуждается в объекте Session.
Как конструировать объект Session, когда конструировать — всё это классу A знать не нужно. Во время работы приложения, контейнер создаст сеанс в нужное время и внедрит его в A через конструктор. Это позволяет отношениям между двумя объектами оставаться слабо связанными.

Класс A должен полагаться на сеанс для правильной работы, объект сеанса передаётся в A контейнером внедрения зависимостей. Но как это всё работает внутри? Как DIC понимает какие зависимости создавать и как их передавать? Дело в том, что php имеет специальное внутреннее API — Reflection API.

Reflection API позволяет коду динамически генерировать объекты, выполнять методы объекта и изменять свойства объекта во время выполнения, и DI-контейнер как раз использует это API для своей работы.

---
prev:[[Что такое SOLID]] next:[[Паттерны проектирования в Laravel]]