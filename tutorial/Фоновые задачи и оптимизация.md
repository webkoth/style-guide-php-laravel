#develop/tree 

В этой главе пойдет речь о фоновых задачах и способах их выполнения в Laravel.
Далеко не весь код приложения всегда вызывается синхронно в ответ на запрос пользователя. До текущего момента вся бизнес-логика проекта выполнялась при вызове роутов по довольно простому принципу:

1. Поступает запрос от клиента, который обрабатывает индексный файл
2. Индексный файл вызывает запуск ядра фреймворка, где и происходит дальнейший диспатчинг запроса
3. Фреймворк находит роут, подходящий для вызываемого URL
4. Роут запускает контроллер
5. В контроллере происходит вызов сервисов, моделей и всего остального, что отвечает за бизнес-логику приложения

Такая последовательность подходит для большинства типовых задачах. Но в сложных приложениях могут быть задачи, которые невозможно выполнить синхронно в момент обработки запроса. Возможной причиной тому может быть либо слишком длительное время выполнения, либо необходимость запуска задачи с определённой регулярностью, без обязательного запуска этого действия запросом пользователя.

Иными словами, нужна возможность выполнять определённый код асинхронно. Сам по себе, PHP плохо дружит с асинхронностью и фоновым запуском кода, но работая под прикрытием фреймворка, мы получаем инструменты, которые всё-таки позволяют выполнить задачи в фоновом режиме.

## Примеры длительных задач

Посмотрим какие могут быть примеры асинхронных задач в типовых веб-приложениях:

- синхронизация данных с внешним сервисом (например, получение информации о новых фильмах)
- обработка тяжелых файлов (ресайз загруженных фотографий)
- отправка email уведомлений

Laravel предлагает следующие возможности для асинхронного запуска кода:

- кастомные artisan-команды, которые можно выполнить из консоли
- планировщик для автоматического запуска таких команд с определённой периодичностью
- поддержка очередей и концепции задач: задача добавляется в очередь, а затем выполняется, когда до неё доходит очередь

prev:[[Виды тестов и тестовые данные]] next:[[Queue]]
