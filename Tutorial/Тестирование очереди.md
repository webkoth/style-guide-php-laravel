#develop/tree 

При тестировании приложений Laravel вы можете «смоделировать» определенные аспекты приложения, чтобы они фактически не выполнялись во время теста. Например, при тестировании контроллера, который отправляет событие, вы можете захотеть имитировать слуашетели событий, чтобы они фактически не выполнялись во время теста. Это позволит вам тестировать только HTTP-ответ контроллера, не беспокоясь о выполнении слушателей событий, поскольку слушатели событий могут быть протестированы в своем собственном тестовом примере.

Laravel предоставляет полезные методы для имитации событий, задач и фасадов из коробки. Эти хелперы в первую очередь обеспечивают дополнительный слой, упрощающий работу с Mockery, потому что вам не нужно вручную выполнять сложные вызовы методов Mockery.

## Что такое моки

**Мокинг** — это создание имитации объекта для целей автоматического тестирования.

При имитации объекта вам нужно будет привязать свой имитируемый экземпляр к контейнеру в качестве привязки экземпляра. Это укажет контейнеру использовать ваш макет объекта вместо создания самого объекта.

Также можно использовать фиктивный метод, предоставляемый классом базового теста Laravel. Например, так мы создадим мок для тестирования класса для загрузки данных о сериале:

```php
$repository = $this->mock(ImportRepository::class, function (MockInterface $mock) use ($showNew) {
	$mock->shouldReceive('getShow')->andReturn(['show' => $showNew, 'genres' => []]);
});
```

## Мокинг фасадов

В отличие от традиционных вызовов статических методов, фасады (включая фасады реального времени) тоже могут быть замоканы. Это дает большое преимущество по сравнению с традиционными статическими методами и предоставляет вам такую же возможность тестирования, как если бы вы использовали традиционное внедрение зависимостей.

При тестировании вам часто может понадобиться имитировать вызов фасада Laravel, который происходит в одном из ваших контроллеров. Например, рассмотрим следующее действие контроллера:

```php
public function index()
{
	$value = Cache::get('key');
}
```

Мы можем имитировать вызов фасада Cache, используя метод shouldReceive, который вернет экземпляр мока Mockery. Поскольку фасады фактически разрешаются и управляются сервисным контейнером Laravel, они имеют гораздо больше возможностей для тестирования, чем типичный статический класс.

## Фейковые очереди

Вы можете использовать фальшивый метод фасада Queue, чтобы предотвратить попадание заданий в настоящую очередь. Скорее всего, достаточно просто выполнить указание поместить данное задание в очередь, поскольку сами задания в очереди могут быть протестированы в другом тестовом классе.

После вызова фейкового метода фасада Queue вы можете добавить проверку, что приложение пыталось поместить задания в очередь:

```php
Queue::fake();

$show = Show::factory()->make(['imdb_id' => 'tt0944947']);

$repository = $this->mock(ImportRepository::class, function (MockInterface $mock) use ($show) {
$mock->shouldReceive('getShow')->andReturn(['show' => $show, 'genres' => []])->once();
});

(new AddShow('tt0944947'))->handle($repository);

Queue::assertPushed(function (SaveShow $job) use ($show) {
return $job->data['show'] === $show;
});

```

Вы можете передать замыкание методам assertPushed или assertNotPushed, чтобы подтвердить, что было отправлено задание, которое проходит заданный «тест на достоверность». Если было отправлено хотя бы одно задание, которое проходит данный тест на истинность, то утверждение будет успешным.

## Тестирование HTTP-запросов

Например, чтобы проинструктировать HTTP-клиент возвращать пустые 200 ответов кода состояния для каждого запроса, вы можете вызвать фейк метод без аргументов:

```php
use Illuminate\Support\Facades\Http;
 
Http::fake();

```

В качестве альтернативы вы можете передать массив поддельному методу. Ключи массива должны представлять шаблоны URL, которые вы хотите подделать, и связанные с ними ответы. Символ * может использоваться как подстановочный знак. Любые запросы к URL-адресам, которые не были подделаны, будут фактически выполнены.

Вы можете использовать метод ответа фасада Http для создания ответов-заглушек/подделок для этих конечных точек.

```php
public function testGetShow()
{
    Http::fake([
    '*' => Http::response(file_get_contents(base_path('tests/Fixtures/show-tvmaze-1.json'))),
    ]);

    $result = $this->repository->getShow('tt0944947');

    $this->assertInstanceOf(Show::class, $result['show']);
    $this->assertIsArray($result['genres']);
    $this->assertFalse($result['show']->exists);
}
```

prev:[[Отличие команд от задач]] next:[[Отличие команд от задач]]
