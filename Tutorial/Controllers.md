#develop/tree 

В философии этого фреймворка нет похожих соглашений по умолчанию, вместо этого всё надо определять явно. Это даёт больше гибкости, но, с другой стороны, приходится писать больше кода.

## Анонимные контроллеры

Laravel позволяет задавать контроллеры прямо внутри определения роутов — как функции обратного вызова. При таком способе, вероятно, это даже нельзя называть контроллерами, а скорее обычными колбеками, привязанными к определённому роуту.
Этот способ подходит только для самых простых приложений и, к тому же, имеет множество ограничений. По этим причинам мы не будет рассматривать данный способ, а сразу перейдем к следующему.

## Контроллеры в виде классов

Этот способ определения контроллеров вам уже хорошо знаком: один класс отвечает за один контроллер. Методы этого класса — действия — отвечают за обработку отдельных URL. Методы-действия могут принимать аргументы в виде параметров запроса.
Отличие от Yii 2 здесь в том, что методы для реализации действий контроллера могут называться как угодно, ведь вы все равно будете явно указывать их во время конфигурации роутинга (читайте в следующей главе).

Легко создать новый контроллер можно с помощью artisan команды:

php artisan make:controller TestController
Будет создана такая заготовка для будущего контроллера:

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class TestController extends Controller
{
    //
}

```

А добавив флаг `--api` к указанной выше команде (php artisan make:controller TestController --api), контроллер создастся с заранее описанными заготовками методов index, store, show, update, delete.

Размещаются такие контроллеры в пространстве имен App\Http\Controllers и в соответствующей папке.

## DI в контроллерах

Как вы уже знаете, в Laravel есть свой service container, который умеет разрешать зависимости. Данный компонент автоматически работает внутри контроллеров, что означает возможность использования type-hint в конструкторе и методы контроллера.
Type-hint означает использование типа аргумента для автоматического получения объекта этого типа при вызове метода контроллера.

Продеменстрируем это всё на примере.
Начнём с того, что создадим новый сервис, который затем будем использовать внутри контроллера.

```php
<?php
namespace App\Services;

class PosterFetcher
{
    public function getPoster($name)
    {
        return 'https://place-hold.it/500?name=' . urlencode($name);
    }
}

```

Этот сервис понадобится нам для получения обложки сериала.
Теперь задействуем его внутри контроллера, который отвечает за возврат информации по выбранному сериалу:

```php
<?php

namespace App\Http\Controllers;

use App\Http\Responses\Success;
use App\Models\Show;
use App\Services\PosterFetcher;

class ShowController extends Controller
{
    /**
     * Display the specified resource.
     *
     * @param Show $show
     * @return Success
     */
    public function show(Show $show, PosterFetcher $fetcher)
    {
        $name = $fetcher->getPoster($show->title);

        return $this->success($show);
    }
}
```

Как видно, мы просто добавили в сигнатуру метода show() новый параметр — объект класса PosterFetcher. Благодаря тому, что у этого аргумента указан его тип, контейнер внедрения зависимостей Laravel сможет автоматически найти этот класс, создать его экземпляр и передать его внутрь метода.

Пожалуй, это всё, что стоит знать о контроллерах на текущий момент. Дело в том, что бо́льшая часть всей работы организации ресурсов и их связывании с URL происходит через настройку роутинга, о чём и пойдет речь далее.

prev:[[REST-API подход]] next:[[Laravel Routes]]
