#develop/tree 

Последний этап работы почти любого API-эндпойнта — это формирование ответа (Response).
Ответ — это то, что получит клиент в ответ на свой запрос. Ответ состоит из полезных данных и метаинформации. Если с полезными данными всё ясно — это сами запрошенные данные, то мета-данные следует рассмотреть отдельно.

Начнём с того, что метаданные нужны для передачи дополнительной информации клиенту. Например, клиенту полезно сообщать тип кодирования возвращаемого контента (JSON, XML или что-то еще). Подобного вида информация, как правило, передаётся через заголовки ответа.

Кроме того, иногда в ответ на запрос сервер возвращает не всю, а лишь часть запрошенного контента. Так происходит при использовании той же пагинации. В этом случае необходимо дополнительно сообщить клиенту как запросить следующую порцию данных и сколько всего страниц.

## Объект ответа

Что вообще является ответом в концепции Laravel?
Если просто, то ответ — это объект класса Symfony\Component\HttpFoundation\Response. Этот объект содержит полезные методы для обогащения его дополнительной информацией.
Поскольку мы разрабатываем API, все ответы у нас будут сформированы в формате JSON, в отличие от классических веб-приложений, где мы возвращали клиенту HTML код.

### Создание своих объектов ответа

Давайте создадим свой класс ответа. Он понадобится нам, чтобы тонко настраивать параметры ответа для пользователя. Например, мы сможем в одном месте задать формат ответа, включив туда нужные заголовки и т. п.
В папке app\Http\Responses создадим новый класс Base, который затем расширим еще парой других классов. Но пока опишем в нём логику для подготовки данных и формирования ответа.

```php
namespace App\Http\Responses;

use Illuminate\Contracts\Support\Arrayable;
use Illuminate\Contracts\Support\Responsable;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

abstract class Base implements Responsable
{
    public function __construct(
        protected mixed $data = [],
        public int $statusCode = Response::HTTP_OK,
    ) {
    }

    /**
     * Create an HTTP response that represents the object.
     *
     * @param  Request $request
     * @return Response
     */
    public function toResponse($request)
    {
        return response()->json($this->makeResponseData(), $this->statusCode);
    }

    /**
     * Преобразование возвращаемых данных к массиву.
     *
     * @return array
     */
    protected function prepareData(): array
    {
        if ($this->data instanceof Arrayable) {
            return $this->data->toArray();
        }

        return $this->data;
    }

    /**
     * Формирование содержимого ответа.
     *
     * @return array|null
     */
    abstract protected function makeResponseData(): ?array;
}
```

Здесь содержатся два важных метода, которые отвечают за подготовку ответа.
В toResponse мы формируем объект ответа, передав туда формат ответа (JSON) и код ответа.
В prepareData проверяем переданные данные и если это коллекция из моделей (подробнее в следующей главе), то преобразуем её в обычный массив.

### JSON response

Вы должно быть обратили внимание на метод json (), который вызван из объекта ответа. Это важный метод, потому что он, во первых, кодирует данные в формат JSON, а во вторых, добавляет необходимые заголовки ответа, чтобы клиент мог адекватно распарсить и обработать полученные данные.

### Разные форматы ответа

В примерах выше мы, в целом, рассмотрели как готовить ответ для успешных запросов. Но в реальном приложении надо также позаботиться и о других ситуациях:

- **обработка ошибок сервера**
когда что-то пошло не так и надо вернуть особенный ответ с подробностями ошибки
- **обработка ошибок валидации**
о валидации пойдет речь позже, но уже сейчас надо предусмотреть получение списка ошибок валидации и показ их в составе ответа
- **пагинация**
пагинация (и другие подобные мета-данных) требует оформления ответа с добавлением дополнительной информации
Для всех таких случаев можно приготовить отдельные классы и использовать при обработки тех же ошибок.
К примеру, создадим класс ответа для ошибок приложения:

```php
use Symfony\Component\HttpFoundation\Response;

class Fail extends Base
{
    public int $statusCode = Response::HTTP_BAD_REQUEST;

    /**
     * ExceptionResponse constructor.
     *
     * @param $data
     * @param string|null $message
     * @param int $code
     */
    public function __construct($data, protected ?string $message = null, int $code = Response::HTTP_BAD_REQUEST)
    {
        parent::__construct([], $code);
    }

    /**
     * Формирование содежимого ответа.
     *
     * @return array
     */
    protected function makeResponseData(): array
    {
        return [
            'message' => $this->message,
            'errors' => $this->prepareData(),
        ];
    }
}
```

Метод makeResponseData обогащает ответ полями с текстом ошибки и списком всех ошибок.

prev:[[Laravel Routes]] next:[[Автоматическая генерация документации]]

