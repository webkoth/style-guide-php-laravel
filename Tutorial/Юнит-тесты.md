#develop/tree 

Итак, давайте разберёмся из чего состоят и как разрабатывать юнит-тесты.
Из прошлой главы вы уже знаете, что юнит-тесты тестируют не поведение, а сам код. Если быть точнее, они тестируют публичные методы объектов, которые участвуют в работе всего приложения.
Давайте сразу посмотрим на пример простого теста, чтобы было проще разобраться во всём по порядку:

Возьмём для простоты этот уже знакомый класс, который мы использовали ранее:

```php
<?php
namespace App\Services;

class PosterFetcher
{
    public function getPoster($name)
    {
        return 'https://place-hold.it/500?name=' . urlencode($name);
    }
}
```

Давайте вначале разберёмся что и как будем тестировать на примере этого класса.

По задумке, метод getPoster() должен возвращать валидную ссылку на изображение с постером переданного фильма или сериала. Следовательно, код, тестирующий этот метод, должен будет:

Создать новый тест. Далее внутри этого теста:
Создать объект этого класса
Вызвать его метод
Проверить, что метод вернул строку
Проверить, что строка является валидной ссылкой на изображение
Теперь воплотим весь этот план в жизнь.

Начнём с создания тестового класса.

Как и многое другое в Laravel, это действие можно автоматизировать с помощью знакомой утилиты artisan. Выполним такую команду:

```shell
php artisan make:test PosterFetcherTest --unit
```

Выполнение команды создаст файл tests/Unit/PosterFetcherTest.php.
Вот как он выглядит:

```php
<?php

namespace Tests\Unit;

use PHPUnit\Framework\TestCase;

class PosterFetcherTest extends TestCase
{
    public function test_example()
    {
        $this->assertTrue(true);
    }
}

```
Здесь мы видим один метод test_example, внутри которого и будет происходить всё тестирование. Давайте заполним его кодом для тестирования класса PosterFetcher.

```php
<?php

namespace Tests\Unit;

use App\Services\PosterFetcher;
use PHPUnit\Framework\TestCase;

class PosterFetcherTest extends TestCase
{
    public function test_fetcher()
    {
        $fetcher = new PosterFetcher();
        $url = $fetcher->getPoster('The Departed');

        // проверяем, что нам вернули строку
        $this->assertIsString($url);
    }
}
```

Итак, в этом коде мы выполнили пункты 2-4: создали объект, вызвали метод и проверили, что он вернул строку. Давайте добавим ещё одну проверку на то, что строка является ссылкой на изображение:

```php
public function test_fetcher()
{
    $fetcher = new PosterFetcher();
    $url = $fetcher->getPoster('The Departed');

    // проверяем, что нам вернули строку
    $this->assertIsString($url);

    $arr = getimagesize($url);
    // проверяем, что функция getimagesize вернула массив
    $this->assertIsArray($arr);
}
```

Как уже стало понятно, основным способом тестирования кода здесь является вызов методов и проверка результата на тип или содержимое. Рассмотрим более подробно какие проверки существуют и как их использовать для правильного тестирования кода.

## PHPUnit

В основе всего юнит-тестирования лежит специальный тестовый фреймворк, ведь именно наследник класса из этого фреймворка мы только что использовали для своего первого юнит-теста.
Основная функция тестового фреймворка — это обеспечивать запуск тестов, предоставлять набор методов для выполнения проверок, предоставлять отчёты по результату тестирования и общему покрытию кода тестами.

Несмотря на то, что phpunit — это отдельная библиотека, вам не понадобится ничего делать для его установки и настройки. Разработчики laravel уже позаботились обо всём этот и тесты с использованием phpunit работают просто «из коробки». Нам остаётся только правильно написать сами тесты и проверить их выполнение.

## Терминология

Нам понадобится разобраться в терминологии тестирования, чтобы понимать из чего состоит организация юнит тестирования.

## Тесткейс

Тесткейс — это отдельный тестовый класс, наследуемый от PHPUnit\Framework\TestCase в котором происходит тестирование всего класса по набору отдельных тестов.

## Test suite

Тестсьют — это обычно директория, которая содержит в себе набор тесткейсов. phpunit можно настроить на запуск сразу всех тестов из сьюта. Это удобно, чтобы разграничивать набор тестов и запускать по необходимости только одну отдельную группу.

## Тест

Непосредственно тестом во всей этой терминологии называется один тестовый метод, который должен проверять отдельный аспект функционирования тестируемого объекта. В примере выше тестом являлся метод test_fetcher, который использовался для проверки работы метода объекта getPoster.

## Ассерт

Ассерты — это ключевая особенность юнит тестирования и именно ассерты являются ключевой частью всего тестового фреймворка.
Ассерт — это утверждение, которое может быть либо истинным, либо ложным. phpunit содержит более сотни доступных ассертов на все случаи жизни. Если хотя бы один ассерт не соблюдается (возвращает false), то весь тест считается проваленным. Из этого следует, что при запуске тестов все ассерты должны быть положительными. Ниже мы рассмотрим самые популярные виды ассертов, которые вам точно пригодятся.

## Виды ассертов

assertTrue/assertFalse — проверяет, что переданное значение является значением типа true или false
assertEquals — проверяет, что переданное и эталонное значения являются одинаковыми (используя нестрогое сравнение, для строго сравнения следует использовать assertSame)
assertIsArray/assertIsString — проверяет, что значение является массивом или строкой
Более подробно с примерами использования ассертов мы можете познакомиться в примерах тестов из учебного проекта.

## Подход к тестированию

Выше мы рассмотрели основные концепции, входящие в состав автоматизированного тестирования. Однако, мало знать из чего состоят тесты на уровне кода. Гораздо важнее разобраться в практике автотестирования — т. е. научиться проектировать и организовывать тесты, которые будут выполняться быстро, надежно, а главное смогут действительно повысить качество приложения, а не просто существовать для вида.
А потому давайте разберёмся с «лучшими практиками» автоматизированного тестирования и научимся писать по настоящему полезные тесты.

## Позитивные и негативные сценарии

При создании тестов вначале собираются требования к тестируемому коду. Затем для каждого требования пишется тест, который проверяет, что оно выполняется.
Сценарий может быть позитивным — когда передаются корректные данные и ожидается успешный результат, и негативными — когда мы передаются неверные данные и ожидается получение сообщения об ошибке или исключения.

## Какие должны быть тесты

Разберём основные требования к составлению тестов, которые крайне желательно соблюдать при разработке.

Тесты должны быть небольшими Правильный тест проверяет только одно требование и укладывается в 15-20 строк кода. Такой тест легко читать и понимать что он делает.
Тесты должны быть воспроизводимыми Следует воздерживаться от использования случайных данных при создании тестов. При многократных запусках тесты должны возвращать один и тот же результат. Это необходимо, чтобы на тест можно было полагаться и не разбираться почему он то работает, то нет.
Тест не должен воспроизводить внутреннюю логику тестируемого объекта Тест не должен знать и полагаться на внутреннюю логику метода, который он вызывает. В этом смысле тестирование должно выполняться по принципу черного ящика и тестируемый код должен просто следовать публичному контракту, который прописан в его сигнатуре.
В нашем примере выше мы знаем, что метод getPoster должен вернуть URL на изображение и этого нам достаточно. Поэтому мы не проверяем ничего, кроме возвращаемого значения и его типа.

## Тестовое окружение

Тесты должны выполняться в контролируемом окружении.

Для тестов в laravel предусмотрено создание специального тестового окружения, которое специально предназначено для ускорения и упрощения всего процесса тестирования.

Например, перед каждым тестом создается временная база данных с заранее подготовленными записями, очищаются папки для хранения временных файлов, а вместо запросов к внешним сервисам используется заглушка, возвращающая заранее подготовленные ответы. Все эти темы будут описаны в следующей главе.

Если не подготовить тестовое окружение, то возможны ошибки, например из-за того, что пытаемся вставить в базу пользователя с уже существующим email, или же не хватает какого-нибудь файла или из-за ошибки внешнего сервиса.

prev:[[Что такое автоматизированное тестирование ?]] next:[[Сиды и моки]]
