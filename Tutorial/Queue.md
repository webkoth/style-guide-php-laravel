#develop/tree 

Пришло время поговорить об очередях.

Очередью называется отложенный способ выполнения задач. Каждая задача состоит из кода, выполняющего нужное действие. Информация о задаче добавляется в очередь и затем, когда наступает время выполнить эту задачу, очередь извлекает всю информацию о ней и запускает нужный код. Далее мы рассмотрим каждый этап этого процесса подробнее.

## Чем является очередь

Сразу стоит разобраться с тем, чем является очередь в контексте этой главы учебника. Говоря про очередь, мы можем подразумевать как саму абстрактную концепцию выполнения задач в фоне, так и непосредственно реализацию этой очереди средствами сторонних сервисов.
Поэтому вначале мы рассмотрим саму концепцию, а затем научимся работать с очередью непосредственно «в коде» для выполнения требований ТЗ проекта.

## Постановка проблемы

В нашем приложении есть возможность добавить новый сериал, если он не был найден в базе сервиса. Пользователь может отправить запрос на добавление сериала в базу, для этого требуется лишь указать IMDB ID этого сериала. Затем наше приложение должно будет обратиться к внешнему сервису за получением всей информации о сериале (название, год, список сезонов). Поскольку получение информации о сериале не обязательно должно выполняться синхронно, а также из-за большой сетевой задержки при обращении к внешнему сервису, имеет смысл вынести такую работу в очередь. Вот как это будет выглядеть.

## План реализации

В первую очередь, следует настроить драйвер очередей: это выполняется через конфиг и не содержит никаких сложностей
Затем определим задачу: класс, который непосредственно будет заниматься добавлением сериала.
Последним шагом нам останется лишь поместить задачу в очередь. Это можно сделать внутри контроллера, отвечающего за обработку запроса на добавление сериала

## Настройка очереди

Драйвер очереди — это способ, которым будут запускаться задачи в очереди.
Дело в том, что реализовать очередь можно на базе разных технологий. Например, обслуживать очередь может специализированный софт вроде Beanstalk, либо это может быть Redis или просто база данных, которая итак уже существует в проекте. Именно этот вариант мы и будем использовать.

Дело в том, что использование базы данных для поддержки очереди будет для нас очень удобно, т. к. позволит просто мониторить и управлять состоянием очереди. Вот какие действия потребуется выполнить:

- для начала создадим специальную таблицу, которая будет управлять очередью:

```shell
php artisan queue:table
php artisan migrate

```

После выполнения этих команд, вы можете убедиться, что в БД появилась новая таблица для хранения очереди: Таблица для очередей

Теперь в конфиге config/queue.php пропишем использование БД в качестве драйвера очереди по умолчанию:

```php
'default' => env('QUEUE_CONNECTION', 'database')
```
## Добавление задачи

Теперь опишем класс задачи, который будет заниматься получением данных о сериале. Это очень простой класс с единственным методом handle, внутри которого и будет происходить вся работа.

```php
<?php

namespace App\Jobs;

use App\Support\Import\ImportRepository;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class AddShow implements ShouldQueue
{
    use Dispatchable;
    use InteractsWithQueue;
    use Queueable;
    use SerializesModels;
    
    public function __construct(private string $imdbId)
    {
    }
    
    public function handle(ImportRepository $repository)
    {
        $data = $repository->getShow($this->imdbId);

        if ($data) {
            SaveShow::dispatch($data);
        }
    }
}

```

Здесь нет вообще ничего важного кроме тела метода handle, где вызывается код для обращения к внешнему сервису, который должен вернуть инфо по сериалу.

## Запуск задачи

Итак, у нас есть задача с кодом для загрузки сериала. Но мы не можем просто взять и вызвать этот класс где-нибудь внутри кода приложения, потому что в этом случае потеряется весь смысл оформлять это как очередь.
Вместо непосредственно выполнения кода задачи, мы должны запланировать её выполнение. Такой процесс называется диспатчингом задачи в очередь. Т.е. вместо непосредственно выполнения задачи, мы передаём в драйвер очереди информацию об этой задаче.

Добавим такой диспатчинг в контроллер ShowController:

```php
public function request(AddShowRequest $request)
{
    AddShow::dispatch($request->imdb);

    return $this->success(null, 201);
}

```

Здесь видно, что с помощью статического вызова AddShow: dispatch мы планируем выполнение этой задачи в асинхронном режиме, а также передаём важную для работы этой задачи информацию — IMDB ID сериала.

## Запуск очереди

Последним шагом нам осталось запустить сам процесс очереди. Это отдельный от работы нашего приложения процесс, который должен быть всегда запущен и автоматически перезапускаться при ошибках. Только такая стабильность гарантирует, что все задачи очереди будут выполнены.

Запуск процесса очереди выполняется одной командой, которая должна остаться работать в вечном цикле:

```bash
php artisan queue:work
```

## Мониторинг очереди

Выполнение задач внутри очереди создаёт определённые сложности, связанные с отладкой и мониторингом их работы. Поэтому в ваших интересах, во-первых, добавить как можно больше отладочной информации внутри самих задач (например, посредством журналирования всех действий в файлы логов). Во-вторых, за процессом выполнения задач очереди можно наблюдать, анализируя содержимое таблицы jobs, если ранее вы выбрали database как драйвер для очередей.

prev:[[Фоновые задачи и оптимизация]] next:[[Тестирование очереди]]
