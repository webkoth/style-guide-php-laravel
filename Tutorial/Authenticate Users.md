#develop/tree 

## Регистрация

Начнём с самого простого — регистрации пользователя.

Добавим в контроллер подобный метод:

```php
public function register(UserRequest $request)
{
    $params = $request->safe()->except('file');
    $user = User::create($params);
    $token = $user->createToken('auth-token');

    return $this->success([
    	'user' => $user,
    	'token' => $token->plainTextToken,
    ], 201);
}
```

Здесь мы создаём модель пользователя, а затем просто вызываем метод createToken. Из прошлой главы вы знаете, что этот метод является частью пакета Sanctum, а значит нам не потребуется его реализовывать и работает он, что называется, из коробки.
Токен, который вернул этот метод надо добавить в ответ клиенту, чтобы тот мог его сохранить и использовать в дальнейшем для всех авторизованных запросов.

## Аутентификация

Итак, вы добавили в приложение регистрацию пользователя. Теперь у нас есть сохранённая информация о пользователе в БД и мы можем добавить еще один метод в контроллер для аутентификации — проверки логина/пароля.

Напишем такой код:

```php
use Illuminate\Support\Facades\Auth;
...

public function login(LoginRequest $request)
{
    if (!Auth::attempt($request->validated())) {
    	abort(401, trans('auth.failed'));
    }

    $token = Auth::user()->createToken('auth-token');

    return $this->success(['token' => $token->plainTextToken]);
}
```

Начнём с того, что мы будем получать доступ к службам аутентификации Laravel через фасад Auth, поэтому нам нужно обязательно импортировать фасад Auth вначале.

Для создания пользовательской сессии сначала следует авторизовать запрос пользователя, проверив переданные логин и пароль. Для этого в Laravel есть метод attempt.

Метод attempt обычно используется для обработки попыток аутентификации из формы входа в систему вашего приложения. В нашем случае привычной HTML-формы нет, поскольку клиентом является мобильное приложение, но вместо этого у нас есть объект запроса с полями логина и пароля.

Что происходит внутри метода attempt?
Там выполняется три основных действия:

- происходит поиск пользователя по переданным данным (логин/email)
- выполняется проверка хэша переданного пароля
- объект пользователя устанавливается для текущего сеанса
Если всё прошло успешно, то метод вернёт значение true.

Следующим шагом создаётся токен доступа для залогиненного пользователя. Вы должны отобразить это значение пользователю сразу после создания токена, что бы пользователь (или клиент) мог передавать токен вместе с запросами требующими авторизации.

## Дополнительные настройки аутентификации

Помните, что службы аутентификации Laravel будут получать пользователей из вашей базы данных на основе конфигурации сервис-провайдера. В файле конфигурации config/auth.php по умолчанию указан «поставщик» Eloquent, и ему предписывается использовать модель App\Models\User для получения пользователей. Вы можете изменить эти значения в файле конфигурации в зависимости от потребностей приложения.

## Получение текущего пользователя

После аутентификации, объект залогиненного пользователя сохраняется внутри текущего экземпляра приложения и к нему очень легко получить доступ через фасад Auth вот так:

```php
use Illuminate\Support\Facades\Auth;
 
$user = Auth::user();

```

## Logout (Удаление сессии пользователя)

Чтобы вручную разлогинить пользователей из приложения, вы можете использовать метод logout, предоставляемый фасадом Auth. Это удалит информацию об аутентификации из сеанса пользователя, чтобы последующие запросы не аутентифицировались.

Вот так может выглядеть метод контроллера для разлогина пользователя. Поскольку в нашей реализации приложения не используются куки и сессии, то в качестве действий по логауту нужно удалить все текущие токены доступа пользователя, так чтобы он не смог повторно использовать их при следующем запросе:

```php
public function logout()
{
	Auth::user()->tokens()->delete();

	return $this->success(null, 204);
}
```

## В заключение

Как стало понятно из этой главы, настроить регистрацию и вход пользователя в приложение очень просто. Но эта простота во многом является следствием выбранного нами подхода: здесь не используются сессии и куки. Вместо этих привычных способов запомнить пользователя мы выбрали токены доступа, а значит вся работа сводится только к их созданию, валидации у удалению.
В этой главе мы не успели рассмотреть только один важный момент: как автоматически проверять валидность токена при каждом запросе и логинить пользователя на основе такого токена. Эти действия выполняются средствами middlewares и об этом пойдет речь дальше.

prev:[[Laravel Sanctum]] next:[[Middlewares]]
