#develop/tree 

Реализация моделей в Laravel очень похожа, поэтому в этой главе мы сфокусируемся на обзоре отличий, а также новых возможностей.

ORM слой в Laravel реализует встроенный компонент под названием Eloquent. Всё дальнейшее повествование посвящено использованию возможностей этой библиотеки.

## Описание модели

Утилита artisan позволяет автоматически сгенерировать модель на основе метаданных таблицы БД (аналогично gii), но мы пройдем весь путь вручную, чтобы лучше разобраться в особенностях моделей Laravel.

## Именование и расположении

По умолчанию, классы моделей следует хранить в директории app\Models.
Eloquent имеет свои соглашения по именованию моделей. Чтобы класс модели автоматически работал с соответствующей таблицей БД без явного указания её имени, должно соблюдаться условие:
имя таблицы = имя класса в строчном регистре и множественном числе.
Пример: модель Contact будет ссылаться на таблицу с именем contacts.

## Получение моделей

Получение моделей из БД также работает очень похожим образом на Yii: у самой модели есть статические свойства, которые позволяют получить одну или несколько записей.

Например, так вы прочитаете весь список жанров: Genre::all(), а так можно получить всего одну запись по первичному ключу: Genre::find(1)

Но что насчёт условий? Например, как прочитать не все записи, а только соответствующие запросу? Эти и подобные действия, включая лимиты и сортировку, делаются через Query Builder, о котором пойдёт речь в следующей главе.

## Коллекции

Коллекции — это ещё одно важное отличие от Yii. Дело в том, что когда Eloquent возвращает список моделей, то это не является привычным массивом, а представляет собой специальную абстракцию — объект класса Illuminate\Support\Collection.
Данная абстракция поддерживает обычную итерацию, т. е. можно использовать в циклах foreach и т. п. Но в дополнение к этому, здесь присутствует множество полезных методов, которые мы позже будем использовать в некоторых сценариях. Например, можно отфильтровать записи по условию или оставить только уникальные значения.

## Добавление и обновление моделей

Добавление и обновление моделей реализовано на 100% также как и в Yii, поэтому мы даже не будем рассматривать эти примеры. Лучше подробнее разберемся с возможностями, которых в Yii не было.

## Upserts

Довольно часто возникает сценарий, при котором вам надо добавить новую запись или обновить существующую, если таковая уже есть. Без поддержки «апсертов» вам бы пришлось вначале делать запрос на поиск модели по критериям, чтобы затем обновить её, либо создать новую модель с нуля. В Laravel в этом нет необходимости, ведь создать/обновить модель можно буквально одной инструкцией.

```php
$show = Show::updateOrCreate(
    ['title' => 'Теория большого взрыва', 'year' => '2010'],
    ['title_original' => 'The big bang theory']
);
```

## Мягкое удаление

Мягкое удаление — это подход, при котором записи никогда физически не удаляются из таблицы БД. Вместо этого в таблицу добавляется поле-флаг, которое указывает, нужно ли скрывать эту запись при чтении. В плюсы такого подхода можно записать возможность легко восстановить запись, а также отсутствие фрагментации БД.
В Yii из коробки нет поддержки мягкого удаления и нам приходилось использовать стороннее расширение, которое с помощью «поведений» добавляло эту поддержку моделям.

Чтобы модель стала поддерживать мягкое удаление достаточно добавить использование специального трейта SoftDeletes

```php
class Show extends Model
{
    use SoftDeletes;
}

```

Конечно, также понадобится добавить в таблицу новое поле deleted_at, куда будет записываться время «удаления» и именно по этому полю ORM будет ориентироваться и скрывать удалённые записи.

Вызов метода delete() для softDelete модели не удалит запись из БД, а любое чтение моделей теперь будет игнорировать записи, где проставлена дата для deleted_at.

## События

Существует стандартный набор событий, которые могут генерировать модели в процессе своего жизненного цикла. Вот их список: retrieved, creating, created, updating, updated, saving, saved, deleting, deleted, trashed, forceDeleted, restoring, restored, and replicating

Так, событие updating отправится перед обновлением модели, а updated — после. Раз используются события, то возникает необходимость их отправлять, подписываться и обрабатывать. Laravel предлагает сразу несколько способов реализовать все эти действия, но мы разберём на пример один, самый универсальный и удобный.

Предположим, вам нужно добавить поведение, которое будет вызываться при каждом сохранении нового сериала. Примером такого поведения может быть получение и сохранение изображения постера.

Поскольку нам необходимо привязаться к событию создания новой модели, то потребуется использовать событие created

Создадим отдельный класс, в котором будет описано поведение при создании модели. Выполним команду, которая создаст новый класс app\Http\Observers:

```shell
php artisan make:observer ShowObserver --model=Show		
```

В созданном классе будет набор пустых методов, чьи имена повторяют названия событий. Добавим наш код внутрь метода created

Дальше необходимо зарегистрировать этот observer, чтобы он вызывался для модели Show. Идём в класс EventServiceProvider и добавляем в метод boot следующий код:

```php
Show::observe(ShowObserver::class);
```

Готово. Теперь при сохранении новой модели будет автоматически вызываться метод created с нашим кодом

prev:[[Автоматическая генерация документации]] next:[[Relationship в Laravel]]
