#develop/tree 

В этой главе мы познакомимся с системой роутинга в Laravel. Роутинг отвечает за сопоставление URL и контроллера, который должен быть вызван.
Как уже было сказано ранее, в Laravel роуты настраиваются более прямолинейно и явно, чем это устроено в Yii 2. Вам потребуется прописать в отдельном файле все роуты приложения. Давайте посмотрим как это работает.

## Где определяются роуты приложения

Для хранения описания роутов в Laravel предусмотрена отдельная папка routes в корне проекта. Там уже будет два файла `web.php` и `api.php`. Поскольку мы реализуем исключительно API-сервер, то и роутинг будем описывать только в api.php.
Этот файл уже автоматически подключён и используется фреймворком, поэтому никаких дополнительных действий делать не нужно; можно сразу приступить к наполнению.

Важный момент: все роуты, описанные внутри этого файла, будут по умолчанию иметь префикс /api. Этот префикс можно поменять, но нам это не потребуется.

## Синтаксис роутов
Каждый роут характеризуется следующими составляющими:

- HTTP-метод
- URL
- параметры запроса
- контроллер и действие, которые обработают этот URL

В Laravel каждый роут — это вызов статического метода объекта-фасада Route.
Сам метод будет называться в зависимости от нужного метода запроса. Примеры допустимых методов:

`get(), post(), put(), patch(), delete()`.

Посмотрим на пример:

```php
Route::post('/register', [AuthController::class, 'register'])
```

Вот как можно расшифровать эту запись:
добавить новый роут для POST-запроса на URL /api/register и вызвать для него метод register контроллера AuthController.

### Параметры роута

Пример выше очень простой, т. к. в нем задан статический URL. Но гораздо чаще нам приходится иметь дело с параметрами внутри URL.
Например, это может быть необходимость показать конкретный эпизод по его номеру. В этом случае номер эпизода является переменной величиной и его следует указать в описании роута в виде маски-плейсхолдера.

```php
Route::get('/episode/{episode}', [EpisodeController::class, 'show'])
```

{episode} здесь означает, что в качестве части URL должен быть номер или название эпизода. Кстати, здесь мы не уточняем тип этого значения, т. е. на место эпизода можно передать как строку, так и число. Если требуется явно ограничить параметр конкретным типом, то для этого можно использовать возможности regexp-интеграции. Подробности можно посмотреть в документации.

## Ресурсные роуты

В Laravel есть возможность упростить создание роутов для типовых CRUD-операций. Это история, когда с одним ресурсом допустимо выполнить несколько операций: создание, чтение, обновление, удаление. Чтобы не описывать каждый метод отдельным вызовом, можно использовать метод resource.
Например, это может выглядеть так:

```php
Route::apiResource('/episode', EpisodeController::class)
```

Несмотря на то, что это удобный способ описать сразу несколько роутов, в учебном проекте мы его не используем и вот почему.
По ТЗ в нашему проекте для основных сущностей поддерживаются далеко не все типы операций. Поэтому описание этих роутов с помощью ресурсного синтаксиса было бы избыточным и нам бы пришлось каждый раз явно указывать какие методы существуют. Вот так:

```php
Route::apiResource('/episode', EpisodeController::class)->only(['index', 'show'])
```

А если only не прописать, то будут созданы все «привычные» методы, и при открытии их пользователь увидит 500 ошибку, о том что метод в контроллере отсутствует. Поэтому давайте придерживаться подхода «явное лучше неявного».

Ещё одна причина нам не использовать ресурсные роуты — это необходимость добавления middlewares на отдельные действия (про middlewares пойдёт речь в следующих главах).

Если вы всё-таки решили использовать ресурсные роуты, то имейте в виду следующее ограничение:
Ресурсный роут создает запись вида Route::get('/path/{model}', 'show'); Если мы хотим добавить еще свою страницу типа Route::get(‘/path/some-route', 'some-method'); наш дополнительный роут обязательно должен быть до ресурсного, иначе первый динамический {model} роут будет перехватывать в том числе и some-route, и будет возвращать 404 ошибку, т. к. не будет находить модель с таким идентификатором.

## Автоматическая загрузка моделей

Из этого раздела вы узнали как использовать параметры внутри роутов. В качестве параметров выступают переменные строкового или числового типа. Но Laravel умеет делать даже больше: автоматически создавать и передавать модель в метод контроллера по её первичному ключу.
Например, вместо добавления в роут ID эпизода, вы можете указать, чтобы сразу загружался сам эпизод. Вот как это работает.

Laravel автоматически подставляет модель, определенную в методе контроллера на основе её типа, если данный тип был задан в сигнатуре метода. Например:

```php
Route::get('/episode/{episode}', [EpisodeController::class, 'show']);
...
public function show(Episode $episode)
{
		return $this->success($episode);
}

```
Т.е. теперь при вызове URL вида /api/episode/23 будет загружена модель с id=23 и передана прямо в контроллер. Если же такой записи в БД не существует, то пользователю автоматически вернётся 404 ошибка.

Кроме того, если в качестве параметра адреса вы хотите использовать не id, а например slug (транслитерированное название) — вы можете указать поле модели по которому Laravel должен искать модель при подстановке: {episode:slug}.

## Artisan

Утилита artisan также будет вам полезна для целей отладки роутов. Так, с помощью artisan можно посмотреть полный список всех роутов, которые загружены и работают в проекте. Делается это вызовом следующей команды:

```shell
$ php artisan route:list -v
```
Внутри себя Laravel кэширует описанные роуты с целью повышения производительности. Иногда это может мешать работе свежих добавленных роутов. В этом случае можно очистить кэш командой

```shell
$ php artisan route:clear
```

prev:[[2_resources/develop/laravel/tutorial/Controllers]] next:[[Responses]]
