#develop/tree 

Самое сложное при разработке юнит-тестов, это правильно организовать работу со внешними ресурсами: базой данных и внешними сервисами, API.
Дело в том, что поскольку ваше приложение активно использует базу данных, становится практически невозможным их тестирование «в вакуме», т. е. тестируемые объекты всё равно будут использовать базу данных и наша задача здесь организовать правильное наполнение тестовой БД так, чтобы это, во-первых, не испортило нормальные, не тестовые данные, а во-вторых, тестовые данные должны быть специально подготовленны для того, чтобы соответствовать задачам тестирования.
Об этих вещах и пойдёт речь в данной главе.

## Тестовая конфигурация

При запуске тестов Laravel автоматически установит тестовую среду конфигурации из-за переменных среды, определенных в файле phpunit.xml.

При необходимости вы можете определить другие значения конфигурации тестирования. Переменные среды тестирования можно настроить прямо в файле phpunit.xml приложения, он дополняет или заменяет значения указанные в.env файле

<php>
    <server name="APP_ENV" value="testing"/>
    <server name="BCRYPT_ROUNDS" value="4"/>
    <server name="CACHE_DRIVER" value="array"/>
    <server name="DB_CONNECTION" value="sqlite"/>
    <server name="DB_FOREIGN_KEYS" value="true"/>
    <server name="DB_DATABASE" value=":memory:"/>
    <server name="MAIL_MAILER" value="array"/>
    <server name="QUEUE_CONNECTION" value="sync"/>
    <server name="SESSION_DRIVER" value="array"/>
    <server name="TELESCOPE_ENABLED" value="false"/>
</php>
Файл .env.testing Вы также можете создать файл.env.testing в корне проекта. Этот файл будет использоваться вместо файла .env при запуске тестов.

## Очистка базы данных

Очень важно сбрасывать состояние базы данных перед каждым тестом, чтобы изменения, оставленные там запуском предыдущего теста, не портили состояние и не мешали запуску следующего.
Laravel умеет самостоятельно очищать базу между запусками тестов, для этого достаточно лишь добавить специальный трейт RefreshDatabase к тестовому классу (используя этот трейт следует убедиться что в тестах используется отдельная тестовая база, во избежание удаления реальных данных):

```php
<?php

namespace Tests\Unit;

use App\Models\User;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class UserModelTest extends TestCase
{
    use RefreshDatabase;
}
```

## Сиды и фабрики

Тема сидов и фабрик вам уже знакома. Надо сказать, что оригинально эти концепции нужны как раз для тестирования и для наполнения БД тестовыми данными. Не будем в этом разделе повторять уже известную вам тему, поэтому сразу перейдём к практическим примерам.

Итак, мы хотим проверить, что у модели Show работает метод getTotalSeasonsAttribute (), который организует подсчет количества сезонов в сериале и возвращает эту цифру, если обратиться к модели таким образом:

$show->total_seasons
Получается, что для проверки работы этого метода нам понадобится вначале заполнить БД нужными значениями:

создать сам сериал
добавить к сериалу заранее известное количество сезонов
вызвать метод и проверить, что он возвращает нужную цифру — количество сезонов

```php
class ShowModelTest extends TestCase
{
    use RefreshDatabase;

    public function testGetTotalSeasons()
    {
        $show = Show::factory()->create();

        Episode::factory()->for($show)->create(['season' => 1]);
        Episode::factory()->for($show)->create(['season' => 2]);

        $this->assertEquals(2, $show->total_seasons);
    }
}
```

Этот подход должен быть вам уже понятен.
Разумеется, вначале необходимо создать соответствующие фабрики в директории database/factories. Затем мы просто используем эти фабрики прямо в коде теста, чтобы создать в БД новые записи ддля сериала и его сезонов. После этого будет достаточно просто вызвать метод $show->total_seasons и сравнить его с результат с эталонным. Как видите, ничего сложного.

## Моки

Моки — это классы-заглушки, которые используются чтобы проверить, что определенная функция была вызвана с определенными аргументами.
Моки незаменимы, когда требуется тестировать классы, работающие с внешними ресурсами. Посколько хорошие тесты должны выполняться быстро и не зависеть от внешних ресурсов, т. е. быть максимально независимыми и изолированными.

Посмотрим как выглядит использование моков на примере тестирования класса, работающего с внешним API:

```php
public function testProcessingJob()
{
    Queue::fake();

    Show::factory()->create(['imdb_id' => null, 'updated_at' => now()->subMonth()]); 
    Show::factory()->create(['imdb_id' => 'tt01', 'updated_at' => now()]); 
    Show::factory()->create(['imdb_id' => 'tt02', 'updated_at' => now()->subMonth()]);
    Show::factory()->create(['imdb_id' => 'tt03', 'updated_at' => now()->subWeek()]);

    $showNew = Show::factory()->make(['updated_at' => now()]);

    $repository = $this->mock(ImportRepository::class, function (MockInterface $mock) use ($showNew) {
    $mock->shouldReceive('getShow')->andReturn(['show' => $showNew, 'genres' => []]);
    });

    (new SyncShows())->handle($repository);

    Queue::assertPushed(SaveShow::class, 2);
}
```

Мы поменяем реализацию класса ImportRepository своим mock классом, у которого должен быть вызван метод getShow (это является одной из проверок теста, если такой метод вызван не будет тест завершится с ошибкой). А так же мы указываем что бы наша mock реализация в ответ на вызов этого метода вернула заранее подготовленные данные сериала и жанров для проверки в тесте.

В указанном примере мы ещё используем fake реализацию Queue фасада, это нужно для подмены механизма обработки очередей в тестах. Эта концепция будет подробнее описана в следующем разделе.

prev:[[Юнит-тесты]] next:[[Функциональные тесты]]
