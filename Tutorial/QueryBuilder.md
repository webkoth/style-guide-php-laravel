#develop/tree 

В этой главе мы познакомимся с реализацией QueryBuilder в Laravel.
Местный QueryBuilder очень похож по своей реализации на его аналог из Yii 2. за некоторыми небольшими исключениями.

Напомним, что QueryBuilder — это реализация «fluent interface» подхода применительно к работе с БД. QueryBuilder отвечает за формирование SQL-запроса, используя цепочку методов, которые вызываются последовательно и отвечают за отдельные части SQL-выражения.

Стоит отдельно отметить, что местная реализация QueryBuilder подходит как для формирования запросов без использования ORM моделей, так и для работы с БД напрямую, без подключения ORM. Здесь мы рассмотрим первый способ, но, в любом случае, синтаксис идентичен и вы сможете использовать QueryBuilder как для получения результата запроса в виде обычного массива, так и в виде коллекции Eloquent-моделей.

## Where
Рассмотрим синтаксис метода where, который, как понятно из названия, отвечает за формирование WHERE части SQL-запроса.
Метод принимает три или два аргумента. Передавая три аргумента вы должны указать:

имя поля
оператор
значение для сравнения
Например, этот код добавит в запрос условие на показ только сериалов с рейтингом выше семи:

```php
$tvshows = $user->shows()->where('rating', '>', 7)->get();
```

Можно передать и два аргумента: имя поля и значения. В этом случае в качестве оператора будет подставлено «=».

## Дополнительные виды where

QueryBuilder предлагает также и дополнительные «помощники» для более удобного использования в типовых запросах. Кратко перечислим самые необходимые методы:

- **orWhere** работает идентично обычному where, но добавляет оператор OR, чтобы можно было объединить в запрос несколько условия
- **whereBetween** добавляет условие на поиск значения внутри диапазона, принимает массив:
- **whereIn** добавляет возможность поиска по списку значений, принимает опять же массив этих значений
- **whereNull** принимает единственный аргумент — название поля и добавляет в запрос условие на равенство этого поля значению типа NULL

## Joins

Разберемся теперь с организацией джойнов в QueryBuilder.
Начнём с плохой новости. Дело в том, что QueryBuilder не поддерживает использование существующих связей внутри ORM-моделей для их реиспользования при построении запроса.
Также Laravel автоматически не генерирует JOIN-инструкции при загрузке связанных моделей. Из главы про отношения вы узнали про жадную загрузку, но она построена на использовании инструкции IN.

Всё это подводит нас к необходимости обязательно использовать join-методы и указывать в них первичные-внешние ключи, даже если в моделях уже есть описанные связи. К сожалению, если вы хотите получить оптимальный запрос с джойнами, то придётся указывать каждый JOIN ручками.

Сама реализация обычных джойнов в Laravel устроена очень просто и почти не отличается от Yii 2. Нам также предлагается использовать методы для inner/left/right джойнов:

Первый аргумент, переданный в join метод — это имя таблицы, с которой происходит объединение, остальные аргументы отвечают за указание внешнего и первичных ключей связываемых таблиц. Вот пример как это выглядит:

```php
$users = DB::table('users')
                ->join('posts', 'users.id', '=', 'posts.user_id')
                ->select('users.*', 'posts.title', 'posts.body')
                ->get();

```

В этом примере мы объединяем таблицы users и posts с помощью метода join (). Первый аргумент — это имя таблицы, с которой мы объединяемся. Второй аргумент — это имя столбца в первой таблице (users), который соответствует столбцу во второй таблице (posts). Третий аргумент — это оператор сравнения между этими двумя столбцами. В этом примере мы сравниваем users.id с posts.user_id.

Затем мы используем метод select () для выбора нужных столбцов из обеих таблиц. В этом примере мы выбираем все столбцы из таблицы users и два столбца title и body из таблицы posts.

Таким образом, мы получаем всех пользователей и их посты в одном запросе. Объединение таблиц с помощью метода join () — это очень мощный инструмент, который позволяет работать с данными из нескольких таблиц в одном запросе и делать это эффективно.

Left и right joins работают идентично, меняется только название методы соответственно:

Дополнительные условия для объединений
Вы также можете указать более сложные условия для организации JOIN-запроса: это можно сделать внутри анонимной функции, которая передается как второй аргумент, после имени таблицы. В замыкание передаётся объект класса Illuminate\Database\Query\JoinClause, который можно расширять дополнительными методами и указывать нужные условия объединения.

## Агрегация

Конечно, QueryBuilder поддерживает и возможности агрегации: т. е. позволяет выполнять функции вроде count, max, min, avg, sum и возвращать результат их работы по определённому полю.
Помимо этих функций, также точно полезными будут методы exists и doesntExist, которые можно использовать вместо count, чтобы проверить существование записи в таблице по условию:

```php
if (!$user->shows()->where('show_id', $show->id)->exists()) {
	throw new RequestException('Сериал не входит список просматриваемых пользователем.');
}
```

## Сырые запросы

Несмотря на все возможности, которые нам даёт QueryBuilder, иногда требуется использовать более сложные конструкции SQL, для которых нет поддержки среди его доступных методов. Как правило, такая необходимость возникает в каких-нибудь заковыристых и нетривиальных запросах.
Laravel предоставляет специальные методы семейства raw для таких случаев. Однако следует помнить, что при использовании сырых запросов нужно быть очень внимательным, т. к. допустить SQL-инъекцию в этом случае становится гораздо проще.
Чаще всего, сырые запросы требуются для формирования WHERE и SELECT частей SQL-выражения.

Метод DB: raw () позволяет добавлять произвольный SQL-код в запрос. Например, мы хотим выбрать всех пользователей и количество постов, которые они опубликовали. Для этого мы можем использовать следующий код:

```php
$users = DB::table('users')
                ->select('users.name', DB::raw('COUNT(posts.id) as post_count'))
                ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
                ->groupBy('users.id')
                ->get();
```
В этом примере мы используем метод DB::raw() для добавления функции COUNT() в наш запрос. Эта функция считает количество записей в столбце id в таблице posts. Мы также используем метод leftJoin() для объединения таблиц users и posts.

Важно отметить, что при использовании метода DB::raw() необходимо быть осторожным, чтобы не допустить SQL-инъекций. Для этого необходимо всегда проверять и фильтровать получившиеся данные перед использованием в запросе.

Таким образом, метод DB::raw() является полезным инструментом для добавления произвольного SQL-кода в запросы. Однако, при использовании этого метода, необходимо быть осторожным и проверять получившийся код на возможность SQL-инъекций.

## Сортировка и группировка

Само собой, QueryBuilder умеет и в сортировку с группировкой. Для этих двух операторов предусмотрены отдельные методы билдера.

### Сортировка

Метод orderBy позволяет сортировать результаты запроса по переданному полю. Первый аргумент этого метода должен быть именем поля, по которому производится сортировка, в то время как второй аргумент определяет направление сортировки: asc или desc:

### Случайная сортировка

У вас может возникнуть потребность отсортировать результаты в случайном порядке. Например, для показа случайного сериала на главной странице приложения. Специальный метод inRandomOrder сможет это сделать за вас. Однако с ним надо быть осторожным: под капотом он использует функцию RANDOM(), а применение этой функции для сортировки по таблице с большим числом записей может быть очень долгим, т. к. индексы в этом случае не применяются.

### Группировка

За группировку отвечает метод groupBy, который принимает один или несколько аргументов. Каждый аргумент — это имя поля в таблице для группировки по нему.

prev:[[Relationship в Laravel]] next:[[Migration]]
